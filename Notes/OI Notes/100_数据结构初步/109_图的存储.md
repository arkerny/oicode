# **图的存储**

```
Author: arkerny
```

图的存储结构主要分四种：**直接存边**、**邻接矩阵**、**邻接表**、**链式前向星**。

### **公式约定：**

​	$n$代表图的点数；$m$​代表图的边数，$d^+(u)$代表点$u$的出度

## **直接存边：**

直接存边的方式比较不常见，使用数组存边，数组的每个元素都包含着一条边的起终点、权值（带权图）。

### **上代码：**

```cpp
struct Edge
{
  int s,e,w;
};
```

### **复杂度：**

**查询是否存在某条边：**$\Theta(m)$​

**遍历一个点的所有出边：**$\Theta(m)$​

**遍历整张图：**$\Theta(n × m)$​

**空间复杂度：**$\Theta(m)$​​

|                        优点                         |     缺点     |
| :-------------------------------------------------: | :----------: |
| 应用于需要多次建图、需要按边权排序（Kruskal）的问题 | 遍历效率低下 |

## **邻接矩阵：**

使用二维数组存储：

```c++
int graph[NUM][NUM];
```

```c++
//对于无向图:
graph[i][j]==graph[j][i]
//对于有向图:
graph[i][j]!=graph[j][i]
//权值：
graph[i][j]=weight;  //存储结点i到j的权值(i到j有边)
graph[i][j]=INF;     //i到j无边
```

### **举个栗子：**

![](https://img-blog.csdn.net/20160511173743769)

### **复杂度：**

**查询是否存在某条边：**$\Theta(1)$

**遍历一个点的所有出边：**$\Theta(n)$

**遍历整张图：**$\Theta(n^2)$

**空间复杂度：**$\Theta(n^2)$

|                             优点                             |                             缺点                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| 适合稠密图的存储；码量少；对边的存储、查询、更新等操作快而简单；只需要一步即可访问和修改 | 空间复杂度太高，存储结点比较多的图会MLE，存储稀疏图时空间浪费太大；一般情况下无法存储重边 |

## **邻接表**

邻接表存储图的实现方式是：给图中的各个结点独自建立一个链表，用链表存储该结点所有的邻接点以及权值。

### **下图即是一个邻接表：**

![](https://img-blog.csdn.net/20160511173718441)

### **核心代码：**

```c++
struct Edge
{
    int y;
    int w;
}
vector <Edge> graph[n];
```

### **建图：**

``` cpp
for(int i=1;i<=m;i++) //m条边
{
    cin>>s>>e>>w;
    graph[s].push_back(e);
    // 针对无向图，加边两次，如下
    // graph[e].push_back(s);
}
```

### **遍历一个点`i`的所有出边：**

``` cpp
for(int j=0;j<graph[i].size();j++)
{
    /*
        blablabla~
    */
}
```

### **复杂度：**

**查询是否存在某条边：**$\Theta(d^+(u))$（如果事先进行了排序就可以使用二分查找做到$\Theta(log(d^+(u)))$）

**遍历一个点的所有出边：**$\Theta(d^+(u))$​

**遍历整张图：**$\Theta(n+m)$

**空间复杂度：**$\Theta(m)$​

|                    优点                    |            缺点            |
| :----------------------------------------: | :------------------------: |
| 存储效率非常高；空间复杂度优；可以存储重边 | 码量较大；访问和修改会变慢 |

## **逆邻接表：**

使用邻接表计算无向图中顶点的入度和出度会非常简单，只需从数组中找到该顶点然后统计此链表中节点的数量即可。而使用邻接表存储有向图时，通常各个顶点的链表中存储的都是以该顶点为弧尾的邻接点，因此通过统计各顶点链表中的节点数量，只能计算出该顶点的出度，如果需要查找每个顶点的入度就需要遍历整个邻接表，在效率上很低下的，所以需要使用逆邻接表。

### **建图：**

``` cpp
for(int i=1;i<=m;i++) //m条边
{
    cin>>s>>e>>w;
    graph[e].push_back(s);
    // 针对无向图，加边两次，如下
    // graph[s].push_back(e);
}
```

## **链式前向星：**

> 邻接矩阵比链式前向星好写，链式前向星比邻接表好写；但邻接矩阵比邻接表效率低，而邻接表比链式前向星效率高。链式前向星是一个比较中庸的数据结构。但虽然链式前向星还未普及，它也是一种优秀的数据结构。 —— 《维基百科 · 链式前向星》
>
> 如果说邻接表是不好写但效率好，邻接矩阵是好写但效率低的话，前向星就是一个相对中庸的数据结构。前向星固然好写，但效率并不高。而在优化为链式前向星后，效率也得到了较大的提升。虽然说，世界上对链式前向星的使用并不是很广泛，但在不愿意写复杂的邻接表的情况下，链式前向星也是一个很优秀的数据结构。 ——《百度百科 · 链式前向星》

邻接表存储非常省空间复杂度，但是还有一种比邻接表更省空间的——**链式前向星**。

### **核心代码：**

```cpp
struct Edge
{
     int next;
     int to;
     int w;
}edge[MAXN];

/*
 edge[i].to表示第i条边的终点，
 edge[i].next表示与第i条边同起点的下一条边的存储位置，
 edge[i].w为边权值。
*/

void add_edge(int s, int e, int w) //加边函数。s为起点，e为终点，w为边权
{
    edge[cnt].to=e; //终点
    edge[cnt].w=w; //权值
    edge[cnt].next=head[s]; //以u为起点的的最后一条边的编号
    head[s]=cnt++; //更新以u为起点的上一条边的编号
}
```

### **建图：**

```c++
for(int i=1;i<=m;i++) //m条边
{
    cin>>s>>e>>w;
    add_edge(s,e,w);
    /*
    加双向边
    add_edge(s,e,w);
    add_edge(e,s,w);
    */
}
```

### **遍历一个点`i`的所有出边：**

```cpp
for(int j=head[i];j!=-1;j=edge[j].next)
{
    /*
        blablabla~
    */
}
```

### **复杂度：**

**查询是否存在某条边：**$\Theta(d^+(u))$

**遍历一个点的所有出边：**$\Theta(d^+(u))$​

**遍历整张图：**$\Theta(n+m)$

**空间复杂度：**$\Theta(m)$​

|                             优点                             |                             缺点                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| 存各种图都很适合；边是带有编号；如果 `cnt` 的初始值为奇数，存双向边时 `i ^ 1` 即是 `i` 的反边 | 不能快速查询一条边是否存在；不能方便地对一个点的出边进行排序 |

