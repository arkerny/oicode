# **排序**

排序是比较重要的一种算法，在生产环境与技术环境中均有应用。

各种排序算法的时间复杂度比较：

![](https://i.loli.net/2021/08/03/l9aAhTX5vLigI8J.png)

冒泡排序、选择排序、插入排序、桶排序均为入门算法，在此不展开赘述。

### **快速排序：**

### **归并排序：详见203_分治**

### **希尔排序：**

### **堆排序：详见113_二叉堆**

### **基数排序：**

### **计数排序：**

## **`sort()`函数**

`sort()`函数想必是OIer们最早接触的STL模板。

在刷题的时候我们经常会碰到排序的问题，如果我们不使用一些排序的方法那我们只能手写排序，这样就会浪费一些时间。而且我们还需要根据需要去选择相关的排序方法。在选择的过程中也需要我们花费一些时间，所以**在明白这些经典排序的原理的情况下**再一遍一遍的手写就比较浪费时间（特殊题目除外，如[洛谷 P1309 [NOIP2011 普及组] 瑞士轮](https://www.luogu.com.cn/problem/P1309)）。

`sort()`函数类似于快速排序算法的时间复杂度$\Theta(nlogn)$，但是不是只是普通的快速排序算法，**它除了对普通的快速排序进行优化，还结合了插入排序和堆排序**。根据不同的数量级别以及不同情况，能自动选用合适的排序方法，对于大部分的排序需求，`sort()`都是可以满足的。

在C++中使用`sort()`函数**需要使用`#include<algorithm>`头文件**。`algorithm`意为"算法"，STL中最重要的头文件之一，提供了大量基于迭代器的非成员模版函数。该头文件的详细使用方法以及包含的函数请参考：[algorithm - C++ Reference](http://www.cplusplus.com/reference/algorithm/?kw=algorithm)。

`sort()`函数可以对给定区间所有元素进行排序。它有三个参数`sort(begin, end, cmp)`，其中`begin`为指向待`sort()`的数组的第一个元素的指针，`end`为指向待`sort()`的数组的最后一个元素的下一个位置的指针，`cmp`参数为排序准则，`cmp`参数可以不写，如果不写的话，**默认从小到大进行排序**。

**举个栗子：**

```c++
int num[10] = {0,6,5,9,1,2,8,7,3,4};
sort(num+1,num+9+1,greater<int>());
```

上面我们说到`sort()`函数可以**自定义排序准则**，以便满足不同的排序情况。使用`sort()`时我们不仅仅可以从大到小排或者从小到大排，还可以按照一定的准则进行排序。比如说我们按照每个数的个位进行从大到小排序，我们就可以根据自己的需求来写一个函数作为排序的准则传入到`sort()`中，举个栗子：

```c++
bool cmp(int x,int y)
{
	return x%10>y%10;
}
```

`sort()`也可以**对结构体进行排序**，比如我们定义一个结构体含有学生的姓名和成绩的结构体`Student`，然后我们按照每个学生的成绩从高到底进行排序。首先我们将结构体定义为：

```c++
struct student
{
	string name;
	int score;
}a[110];
```

根据排序要求我们可以将比较函数写为：

```c++
bool cmp(student temp1,student temp2)
{
	return temp1.score>temp2.score;
}
```

